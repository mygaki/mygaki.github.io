<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jenkins学习笔记</title>
      <link href="2021/06/27/jenkins/"/>
      <url>2021/06/27/jenkins/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mygaki.github.io/img/image-20210627224140801.png" alt="image-20210627224140801"></p><h1 id="Jenkins学习笔记"><a href="#Jenkins学习笔记" class="headerlink" title="Jenkins学习笔记"></a>Jenkins学习笔记</h1><hr><p>软件开发的生命周期：</p><ul><li><p>需求分析</p></li><li><p>需求设计</p></li><li><p>需求实现</p></li><li><p>测试</p></li><li><p>优化&amp;维护</p></li></ul><p>软件开发模型 </p><ul><li>瀑布模型</li></ul><p><img src="https://mygaki.github.io/img/image-20210627210958658.png" alt="image-20210627210958658"></p><p>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量</p><p>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险</p><p>通过过多的强制完成日期和里程碑来跟踪各个项目阶段</p><p>瀑布模型的突出缺点是不适应用户需求的变化</p><ul><li>敏捷开发</li></ul><p><img src="https://mygaki.github.io/img/image-20210627213800241.png" alt="image-20210627213800241"></p><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p><img src="https://mygaki.github.io/img/image-20210627214902436.png" alt="image-20210627214902436"></p><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><p>组成要素</p><ol><li>一个自动化构建的过程，包括提交，检出、编译、测试、报告统计、构建打包，部署等都是自动完成的，无需人工干预</li><li>代码存储库，如SVN,GIT</li><li>持续集成服务器，jenkins就是一个配置简单和使用方便的持续集成服务器</li></ol><p>持续集成的好处</p><ol><li><p>快速发现错误，每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易</p></li><li><p>防止分支大幅偏离主干，如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成</p></li><li><p>更快速的发布更新，持续集成可以帮助团队更快速、更积极的发布程序和更新程序。在发布时可自动完成大量重复的工作、节省人力。</p></li></ol><h2 id="Jenkins介绍"><a href="#Jenkins介绍" class="headerlink" title="Jenkins介绍"></a>Jenkins介绍</h2><p>jenkins 是一款流行的开源持续集成工具，广泛应用于项目开发，具有自动化构建，测试和部署等功能</p><p>Jenkins的特征：</p><ul><li>开源的java语言开发持续集成工具，支持持续集成，持续部署</li><li>易于安装部署配置</li><li>消息通知及测试报告</li><li>分布式构建和测试</li><li>文件识别：Jenkins能够跟踪哪次构建生成哪些jar,哪次构建使用哪个版本的jar等</li><li>丰富的插件支持</li></ul><h2 id="Jenkins安装和持续集成环境配置"><a href="#Jenkins安装和持续集成环境配置" class="headerlink" title="Jenkins安装和持续集成环境配置"></a>Jenkins安装和持续集成环境配置</h2><p><img src="https://mygaki.github.io/img/image-20210704225933156.png" alt="image-20210704225933156"></p><p>准备三台centos主机</p><ol><li><p>安装相关依赖</p><blockquote><p>yum -y install policycoreutils openssh-server openssh-clients postfix</p></blockquote></li><li><p>启动ssh服务和设置为开机启动</p><blockquote><p>systemctl enable sshd &amp;&amp; sudo systemctl start sshd</p></blockquote></li><li><p>设置postfix开机自启，并启动，postfix支持gitlab发信功能</p><blockquote><p>systemctl enable postfix &amp;&amp; systemctl start postfix</p></blockquote></li><li><p>开放ssh以及http服务，然后重新加载防火墙列表(如果关闭了防火墙，就不用设置)</p><blockquote><p>firewall-cmd –add-service=ssh –permanent</p><p>firewall-cmd –add-service=http –permanent</p><p>firewall-cmd –reload</p></blockquote></li><li><p>安装gitlab</p><blockquote><p>cat &gt; /etc/yum.repos.d/gitlab-ce.repo &lt;&lt; EOF</p><p>[gitlab-ce]<br>name=Gitlab CE Repository<br>baseurl=<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/</a><br>gpgcheck=0<br>enabled=1</p><p>EOF</p><p>yum makecache</p><p>yum install gitlab-ce</p></blockquote></li><li><p>修改gitlab配置</p><blockquote><p>vi /etc/gitlab/gitlab.rb</p></blockquote><p>external_url ‘<a href="http://10.0.0.200:82&#39;">http://10.0.0.200:82&#39;</a></p><p>nginx[‘listen_port’] = 82</p></li><li><p>重启gitlab服务</p><blockquote><p>gitlab-ctl reconfigure</p><p>gitlab-ctl restart</p></blockquote></li><li><p>修改gitlab初始root密码</p><blockquote><p><em>gitlab-rails console -e production</em></p><p>执行命令： <code>user = User.where(id: 1).first</code>，此 user 则表示 root 用户</p><p>执行命令：<code>user.password = &#39;secret_pass&#39;</code>修改密码， <code>user.password_confirmation = &#39;secret_pass&#39;</code> 确认密码</p><p>执行命令： <code>user.save!</code> 保存密码</p><p>执行命令： <code>exit</code> 退出控制台</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes学习笔记</title>
      <link href="2021/06/05/kubernetes/"/>
      <url>2021/06/05/kubernetes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mygaki.github.io/img/image-20210627224213774.png" alt="image-20210627224213774"></p><h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="# kubernetes"></a># kubernetes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>kubernetes 简称K8S，其中8代表了”ubernete”的8个字符，是一个开源的自动化容器编排引擎</p><ul><li><p>是谷歌在2014年开源的容器化集群管理系统（go语音开发的）</p></li><li><p>使用K8S进行容器化应用部署</p></li><li><p>使用K8S利于应用扩展</p></li><li><p>K8S目标实施让部署容器化更加简洁和高效</p></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>自动装箱（自动部署）</p></li><li><p>自动修复（自愈能力，监控检查）</p></li><li><p>水平扩展</p></li><li><p>服务发现（负载均衡）</p></li><li><p>滚动更新</p></li><li><p>版本回退</p></li><li><p>密钥和配置管理</p></li><li><p>存储编排</p></li><li><p>批处理（一次性和定时任务）</p></li></ul><h2 id="K8S集群架构组件"><a href="#K8S集群架构组件" class="headerlink" title="K8S集群架构组件"></a>K8S集群架构组件</h2><p><img src="https://mygaki.github.io/img/image-20210606232443179.png" alt="image-20210606232443179"></p><p>Master(主控节点) 和 worker node(工作节点)</p><ol><li><p>master组件（集群控制节点，对集群进行调度管理，接收集群外用户对集群的操作请求）</p><ul><li>ApiServer<ul><li>集群统一入口，以restful方式，交给<strong>etcd</strong>[^1]存储</li></ul></li><li>scheduler<ul><li>节点调度，选择node节点应用部署</li></ul></li><li>controller-manager<ul><li>处理集群中常见后台任务，一个资源对应一个控制器</li></ul></li><li>etcd<ul><li>存储系统，保存集群相关数据</li></ul></li></ul></li><li><p>worker node</p><ul><li>kubelet<ul><li>类比master派给node节点的代表，负责管理节点中的容器</li></ul></li><li>kube-proxy<ul><li>提供网络代理，实现负载均衡等操作</li></ul></li></ul></li></ol><h2 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h2><ol><li><p>Pod</p><ul><li>最小组成单元</li><li>一组容器的集合</li><li>共享网络</li><li>生命周期是短暂的</li></ul></li><li><p>Controller</p><ul><li>确保预期的Pod的副本数量</li><li>无状态和有状态应用部署</li><li>确保所有的node运行同一个Pod</li><li>一次性任务和定时任务 </li></ul></li><li><p>Service</p><ul><li>定义一组Pod的访问规则</li></ul></li></ol><blockquote><p>由Serivce对外创建访问规则，由Controller创建Pod并运行</p></blockquote><h2 id="搭建K8S环境平台规划"><a href="#搭建K8S环境平台规划" class="headerlink" title="搭建K8S环境平台规划"></a>搭建K8S环境平台规划</h2><ul><li><p>单master集群部署</p><p><img src="https://mygaki.github.io/img/image-20210613014405841.png" alt="image-20210613014405841"></p></li><li><p>多master集群部署 ( 实现高可用 )</p><p><img src="https://mygaki.github.io/img/image-20210613014611137.png" alt="image-20210613014611137"></p></li></ul><p>部署kubunetes集群主要有两种方式：</p><ol><li>kubeadm<ul><li>kubeadm是一个K8S部署工具，提供kubeadm init和kubeadm join,用于快速部署kubernetes集群</li></ul></li><li>二进制包<ul><li>从github下载发行版的二进制包，手动部署每个组件，组成kubenetes集群。</li></ul></li></ol><p>kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署，虽然麻烦点，但可以学习很多工作原理，也利于后期维护</p><h2 id="Kubernetes-部署环境要求"><a href="#Kubernetes-部署环境要求" class="headerlink" title="Kubernetes 部署环境要求"></a>Kubernetes 部署环境要求</h2><ol><li><p>一台或多台机器，操作系统CentOS 7.x-86_x64</p></li><li><p>硬件配置：内存2G或者2G+, CPU 2核或CPU 2核+</p></li><li><p>集群内各个机器之间能相互通信</p></li><li><p>集群内各个机器可以访问外网，需要拉取镜像（非必需）</p></li><li><p>禁止swap分区（swap，这个当内存不足时，linux会自动使用swap，将部分内存数据存放到磁盘中，这个这样会使性能下降，为了性能考虑推荐关掉）</p></li></ol><h2 id="提前准备-根据部署规化，在每台主机上执行"><a href="#提前准备-根据部署规化，在每台主机上执行" class="headerlink" title="提前准备(根据部署规化，在每台主机上执行)"></a>提前准备(根据部署规化，在每台主机上执行)</h2><p>关闭防火墙： </p><pre class=" language-shell"><code class="language-shell">systemctl stop firewalldsystemctl disable firewalld</code></pre><p>关闭selinux</p><pre class=" language-shell"><code class="language-shell">sed -i 's/enforcing/disabled/' /etc/selinux/config   #永久setenforce 0 #临时</code></pre><p>关闭swap</p><pre class=" language-shell"><code class="language-shell">sed -ri 's/.*swap.*/#&/' /etc/fstab  #永久swapoff -a  #临时</code></pre><p>设置主机名</p><pre class=" language-shell"><code class="language-shell">hostnamectl set-hostname <hostname></code></pre><p>添加hosts</p><pre class=" language-shell"><code class="language-shell">cat >> /etc/hosts << EOF10.0.0.100 vmmaster10.0.0.101 vmnode110.0.0.102 vmnode2EOF</code></pre><p>将桥接的ipv4流量传递到iptables的链上</p><pre class=" language-shell"><code class="language-shell">cat > /etc/sysctl.d/k8s.conf << EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system #生效</code></pre><p>时间同步</p><pre class=" language-shell"><code class="language-shell">yum install ntpdate -yntpdate time.windows.com</code></pre><h2 id="使用kubeadm部署kebunetes"><a href="#使用kubeadm部署kebunetes" class="headerlink" title="使用kubeadm部署kebunetes"></a>使用kubeadm部署kebunetes</h2><p>总体步骤：</p><ol><li>创建一个Master节点<ul><li>kubeadmin init</li></ul></li><li>将Node节点加入到Master集群中<ul><li>kubeadm join &lt;Master节点的IP和端口&gt;</li></ul></li></ol><p>具体执行：（单master, 3个node）</p><p>K8s默认的CRI(容器运行时)为Docker,  因此先安装Docker</p><pre class=" language-shell"><code class="language-shell"># 更新docker的yum源yum update     # 卸载旧版本(如果安装过旧版本的话)yum remove docker  docker-common docker-selinux docker-engine  # 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的yum install -y yum-utils device-mapper-persistent-data lvm2# 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 可以查看所有仓库中所有docker版本，并选择特定版本安装yum list docker-ce --showduplicates | sort -r# 安装Docker，命令：yum install docker-ce-版本号，我选的是17.12.1.ceyum install docker-ce-17.12.1.ce# 启动Docker，命令：systemctl start docker，然后加入开机启动systemctl start dockersystemctl enable docker# 验证安装是否成功(有client和service两部分表示docker安装启动都成功了)docker version # 配置加速器cat >/etc/docker/daemon.json << EOF&#123;  "registry-mirrors": ["https://12xtdzon.mirror.aliyuncs.com"]&#125;EOF然后执行：systemctl restart  docker</code></pre><p>安装kubeadm、kebulet、kebuctl</p><pre class=" language-shell"><code class="language-shell"># 添加k8s的阿里云的yum源cat > /etc/yum.repos.d/kubernetes.repo  << EOF[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF# 安装kubeadm, kubelet和kubectlyum install kubelet-1.19.4 kubeadm-1.19.4 kebectl-1.19.4 -yPS: 如果报错：nicodeDecodeError: 'ascii' codec can't decode byte 0xbc in position 3746:则在 /usr/share/yum-cli/yummain.py中加入三行：import sysreload(sys)sys.setdefaultencoding('gbk')systemctl enable kubelet# 查看是否安装完成yum list installed | grep kubeletyum list installed | grep kubeadmyum list installed | grep kubectl</code></pre><p>查看版本： kubelet –version<br>kubelet : 运行在cluster所有节点上，负责启动POD和容器<br>kubeadm: 用于初始化cluster<br>kubectl: kebunetes命令行工具，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件 </p><p>部署Kubenetes Master节点， 在<strong>Master</strong>节点执行</p><pre class=" language-shell"><code class="language-shell">kubeadm init \--apiserver-advertise-address=10.0.0.100 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.19.4 \--service-cidr=10.96.0.0/12 \--pod-network-cidr=10.244.0.0/16mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 查看是否部署完成kubectl get nodes -o wide</code></pre><p>node节点加入Kubenetes Master, 在Worker Node上执行</p><pre class=" language-shell"><code class="language-shell"># 注意修改tokenkubeadm join 10.0.0.100:6443 --token e0evhb.mjvp8xgcj0cdmzrt \    --discovery-token-ca-cert-hash sha256:d5d25254ec7ee7ee5c287c260c5ae36f1eda6047c2f9fc819b099c56834388ac    # 在master节点上查看是否部署完成kubectl get nodes -o wide</code></pre><p>常见错误：</p><p><img src="https://mygaki.github.io/img/image-20210612162045453.png" alt="image-20210612162045453"></p><p>输入 : sysctl -w net.ipv4.ip_forward=1 就可以解决这个问题了</p><p>在Master安装pod网络插件</p><pre class=" language-shell"><code class="language-shell">kubectl apply -f ./kube-flannel.yml  #建议从网络下载，原地址需要翻墙# 在master上查看是否部署完成, 稍等一会，检查是否变为Readykubectl get nodes -o wide# 查看有多少系统命名空间的podkubectl get pods -n kube-system</code></pre><p>k8s部署容器化应用</p><ol><li>制作镜像（自己制作或者仓库pull）</li><li>通过控制器管理Pod( 镜像启动得到一个容器，放到pod里 )</li><li>暴露应用，以便外界可以访问</li></ol><p>创建控制器管理Pod ( worker nodes没有镜像时会从仓库拉取)</p><pre class=" language-shell"><code class="language-shell">kubectl create deployment <name> --image=你的镜像</code></pre><p>暴露端口</p><pre><code>kubectl expose deployment &lt;name&gt; --port=&lt;port&gt; --type=NodePort</code></pre><pre class=" language-shell"><code class="language-shell"># 查看节点kubectl get nodes/node -n <namespace># 查看服务kubectl get service/service/svc -n <namespace># 查看控制器kubectl get deployment/deploy -n <namespace># 查看podkubectl get pods/pod -n <namespace>node(节点) -> service(服务) ->  deployment(控制器) -> pod -> docker# 查看命名空间  默认名称空间为defaultkubectl get namespaces/namespace/ns# 删除控制器kubectl delete deployment <name># 空运行kubectl create deployment nginx --image=nginx --dry-run -o yaml > deploy.yaml# yaml文件方式部署kubectl apply -f deploy.yaml# 查看pod结构描述kubectl describe pod <podname> -n <namespace># 查看pod日志kubectl logs <podname> -n <namespace></code></pre><h2 id="使用二进制方式部署Kubenetes"><a href="#使用二进制方式部署Kubenetes" class="headerlink" title="使用二进制方式部署Kubenetes"></a>使用二进制方式部署Kubenetes</h2><ol><li><p>安装cfssl证书生成工具(<strong>Master</strong>)</p><pre class=" language-shell"><code class="language-shell">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslmv cfssljson_linux-amd64 /usr/local/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre></li><li><p>生成自签名ETCD服务器证书(<strong>Master</strong>)</p><pre class=" language-shell"><code class="language-shell">mkdir -p ~/TLS/&#123;etcd,k8s&#125;cd /root/TLS/etcdcat > ca-config.json << EOF&#123;  "signing": &#123;    "default": &#123;      "expiry": "87600h"  #证书过期时间h单位    &#125;,    "profiles": &#123;      "www": &#123;         "expiry": "87600h",         "usages": [            "signing",            "key encipherment",            "server auth",            "client auth"        ]      &#125;    &#125;  &#125;&#125;EOF#ca机构请求cat > ca-csr.json << EOF&#123;    "CN": "etcd CA",    "key": &#123;        "algo": "rsa",        "size": 2048    &#125;,    "names": [        &#123;            "C": "CN",            "L": "Beijing",            "ST": "Beijing"        &#125;    ]&#125;EOF#生成ca证书：读取上边两个文件生成证书cfssl gencert -initca ca-csr.json | cfssljson -bare ca -#etcd域名证书，需要把etcd节点ip都写进去cat > server-csr.json << EOF&#123;    "CN": "etcd",    "hosts": [    "192.168.245.128",    "192.168.245.129"    ],    "key": &#123;        "algo": "rsa",        "size": 2048    &#125;,    "names": [        &#123;            "C": "CN",            "L": "BeiJing",            "ST": "BeiJing"        &#125;    ]&#125;EOF#签名服务器证书cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</code></pre></li><li><p>安装ETCD（<strong>Master</strong>）</p><pre class=" language-shell"><code class="language-shell"># 创建工作目录，下载二进制etcd源码文件mkdir -p /opt/etcd/&#123;bin,cfg,ssl&#125;cd ~wget https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gztar -xf etcd-v3.4.9-linux-amd64.tar.gzcp /root/TLS/etcd/*.pem /opt/etcd/ssl/cp -r etcd-v3.4.9-linux-amd64/etcd* /opt/etcd/bin/cat > /opt/etcd/cfg/etcd.conf << EOF#[Member]ETCD_NAME="etcd-1"ETCD_DATA_DIR="/var/lib/etcd/default.etcd"ETCD_LISTEN_PEER_URLS="https://192.168.245.128:2380"ETCD_LISTEN_CLIENT_URLS="https://192.168.245.128:2379"#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.245.128:2380"ETCD_ADVERTISE_CLIENT_URLS="https://192.168.245.128:2379"ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.245.128:2380,etcd-2=https://192.168.245.129:2380"ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"ETCD_INITIAL_CLUSTER_STATE="new"EOFcat > /usr/lib/systemd/system/etcd.service << EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyEnvironmentFile=/opt/etcd/cfg/etcd.confExecStart=/opt/etcd/bin/etcd --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --peer-cert-file=/opt/etcd/ssl/server.pem --peer-key-file=/opt/etcd/ssl/server-key.pem --trusted-ca-file=/opt/etcd/ssl/ca.pem --peer-trusted-ca-file=/opt/etcd/ssl/ca.pem --logger=zapRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</code></pre></li><li><p>安装ETCD(<strong>Node</strong> ， 多个参照此配置)</p><pre class=" language-shell"><code class="language-shell"># 复制pem文件到node节点mkdir -p ~/TLS/&#123;etcd,k8s&#125;cd /root/TLS/etcdscp root@192.168.245.128:/root/TLS/etcd/* .cd ~wget https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gztar -xf etcd-v3.4.9-linux-amd64.tar.gzcp /root/TLS/etcd/*.pem /opt/etcd/ssl/cp -r etcd-v3.4.9-linux-amd64/etcd* /opt/etcd/bin/cat > /opt/etcd/cfg/etcd.conf << EOF#[Member]ETCD_NAME="etcd-2"ETCD_DATA_DIR="/var/lib/etcd/default.etcd"ETCD_LISTEN_PEER_URLS="https://192.168.245.129:2380"ETCD_LISTEN_CLIENT_URLS="https://192.168.245.129:2379"#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.245.129:2380"ETCD_ADVERTISE_CLIENT_URLS="https://192.168.245.129:2379"ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.245.128:2380,etcd-2=https://192.168.245.129:2380"ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"ETCD_INITIAL_CLUSTER_STATE="new"EOFcat > /usr/lib/systemd/system/etcd.service << EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyEnvironmentFile=/opt/etcd/cfg/etcd.confExecStart=/opt/etcd/bin/etcd --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --peer-cert-file=/opt/etcd/ssl/server.pem --peer-key-file=/opt/etcd/ssl/server-key.pem --trusted-ca-file=/opt/etcd/ssl/ca.pem --peer-trusted-ca-file=/opt/etcd/ssl/ca.pem --logger=zapRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</code></pre></li><li><p>启动服务(<strong>Master,Node</strong>)</p><pre class=" language-shell"><code class="language-shell">systemctl daemon-reloadsystemctl enable etcdsystemctl start etcd</code></pre></li><li><p>生成自签名k8s apiserver证书</p><pre class=" language-shell"><code class="language-shell">cat > ca-csr.json << EOF&#123;    "CN": "k8sapiserver ca",    "key": &#123;        "algo": "rsa",        "size": 2048    &#125;,    "names": [        &#123;            "C": "CN",            "L": "BeiJing",            "ST": "BeiJing"        &#125;    ]&#125;EOFcat > ca-config.json << EOF&#123;  "signing": &#123;    "default": &#123;      "expiry": "876000h"    &#125;,    "profiles": &#123;      "kubernetes": &#123;         "expiry": "876000h",         "usages": [            "signing",            "key encipherment",            "server auth",            "client auth"        ]      &#125;    &#125;  &#125;&#125;EOFcat > kube-proxy-csr.json << EOF&#123;  "CN": "kube-proxy",  "hosts": [],  "key": &#123;    "algo": "rsa",    "size": 2048  &#125;,  "names": [    &#123;      "C": "CN",      "L": "BeiJing",      "ST": "BeiJing"    &#125;  ]&#125;EOFcat > server-csr.json << EOF&#123;    "CN": "kube-apiserver",    "hosts": [      "192.168.245.1",      "127.0.0.1",      "kubernetes",      "kubernetes.default",      "kubernetes.default.svc",      "kubernetes.default.svc.cluster",      "kubernetes.default.svc.cluster.local",      "192.168.245.128",      "192.168.245.129"    ],    "key": &#123;        "algo": "rsa",        "size": 2048    &#125;,    "names": [        &#123;            "C": "CN",            "L": "BeiJing",            "ST": "BeiJing"        &#125;    ]&#125;EOF# 生成CA证书cfssl gencert -initca ca-csr.json | cfssljson -bare ca -# 签名server证书cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server# 签名kube-proxy证书cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</code></pre></li><li><p>部署Kubenete Master组件(docker/etcd/kube-apiserver/kube-controller-manager/kube-scheduler)</p><pre class=" language-shell"><code class="language-shell"># 下载并解压cd /optwget https://dl.k8s.io/v1.20.7/kubernetes-server-linux-amd64.tar.gztar -zxvf kubernetes-server-linux-amd64.tar.gzcd kubernetesmkdir /opt/kubernetes/server/conf/vim /opt/kubernetes/server/conf/apiserver KUBE_API_ADDRESS="--insecure-bind-address=0.0.0.0"KUBE_API_PORT="--port=8886"KUBE_ETCD_SERVERS="--etcd-servers=http://10.9.0.46:2379"KUBE_SERVICE_ADDRESSES="--service-cluster-ip-range=169.169.0.0/16"KUBE_ADMISSION_CONTROL="--admission-control=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ResourceQuota"KUBE_API_LOG="--logtostderr=false --log-dir=/home/k8s-t/log/kubernets --v=2"KUBE_API_ARGS=" "</code></pre><p>（未完待续）</p></li></ol><p>[^1]: <em>etcd</em> 是一个高可用的 Key/Value 存储系统，主要用于分享配置和服务发现</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
